<!-- DataTables + PapaParse + jQuery from CDN -->
<script src="https://cdn.jsdelivr.net/npm/papaparse@5.3.2/papaparse.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js"></script>
<link rel="stylesheet" href="https://cdn.datatables.net/1.13.1/css/jquery.dataTables.min.css">
<script src="https://cdn.datatables.net/1.13.1/js/jquery.dataTables.min.js"></script>

<style>
  /* Basic styling for nested checkboxes */
  .category-block {
    border: 1px solid #ccc;
    padding: 8px;
    margin-bottom: 8px;
  }
  .sub-block {
    border-left: 2px dashed #ccc;
    margin-left: 1em;
    padding-left: 1em;
    margin-top: 4px;
  }
  /* DataTables width */
  table {
    width: 100%;
  }
  .details {
    margin-top: 1em;
  }
</style>

<h2>HypoBench Leaderboard</h2>
<p>Select tasks below to filter the aggregated results in real time:</p>

<!-- Container for nested checkboxes -->
<div id="task-selector" style="margin-bottom: 1em;"></div>

<!-- The leaderboard table -->
<table id="leaderboard" class="display"></table>

<script>
// 1) Define your multi-level categories object.
//    EXACTLY match the Task values from your CSVs (with underscores, not slashes).
// If you want to remove 'All', you can do that.
const categories = {
  All: null,  // Means no filtering
  admission: {
    "level 1": [
      "admission_level_1_base"
    ],
    "level 2": [
      "admission_level_2_depth_2",
      "admission_level_2_distractor_3",
      "admission_level_2_noise_10",
      "admission_level_2_size_5"
    ],
    "level 3": [
      "admission_level_3_depth_3",
      "admission_level_3_distractor_6",
      "admission_level_3_noise_20",
      "admission_level_3_size_10"
    ],
    "level 4": [
      "admission_level_4_depth_4",
      "admission_level_4_distractor_10",
      "admission_level_4_noise_30",
      "admission_level_4_size_15"
    ]
  },
  admission_adv: {
    "level 1": [
      "admission_adv_level_1_base"
    ],
    "level 2": [
      "admission_adv_level_2_depth_2",
      "admission_adv_level_2_distractor_3",
      "admission_adv_level_2_noise_10",
      "admission_adv_level_2_size_5"
    ],
    "level 3": [
      "admission_adv_level_3_depth_3",
      "admission_adv_level_3_distractor_6",
      "admission_adv_level_3_noise_20",
      "admission_adv_level_3_size_10"
    ],
    "level 4": [
      "admission_adv_level_4_depth_4",
      "admission_adv_level_4_distractor_10",
      "admission_adv_level_4_noise_30",
      "admission_adv_level_4_size_15"
    ]
  },
  election: {
    "level 0": [
      "election_level0",
      "election_level0_nosubtlety"
    ],
    "level 1": [
      "election_level1",
      "election_level1_nosubtlety"
    ],
    "level 2": [
      "election_level2",
      "election_level2_nosubtlety"
    ],
    "level 3": [
      "election_level3",
      "election_level3_nosubtlety"
    ],
    "level 4": [
      "election_level4",
      "election_level4_nosubtlety"
    ],
    "level 5": [
      "election_level5",
      "election_level5_nosubtlety"
    ],
    "controlled": [
      "election_controlled_5_0_0",
      "election_controlled_10_0_0",
      "election_controlled_15_0_0",
      "election_controlled_20_0_0",
      "election_controlled_20_0.1_0",
      "election_controlled_20_0.2_0",
      "election_controlled_20_0.3_0",
      "election_controlled_20_0_0.1",
      "election_controlled_20_0_0.2",
      "election_controlled_20_0_0.3",
      "election_controlled_20_0.1_0.1",
      "election_controlled_20_0.2_0.2",
      "election_controlled_20_0.3_0.3"
    ],
    "counterfactual": [
      "election_counterfactual_normal",
      "election_counterfactual_counterfactual"
    ]
  },
  preference: {
    "level 0": [
      "preference_level0",
      "preference_level0_nosubtlety"
    ],
    "level 1": [
      "preference_level1",
      "preference_level1_nosubtlety"
    ],
    "level 2": [
      "preference_level2",
      "preference_level2_nosubtlety"
    ],
    "level 3": [
      "preference_level3",
      "preference_level3_nosubtlety"
    ],
    "level 4": [
      "preference_level4",
      "preference_level4_nosubtlety"
    ],
    "level 5": [
      "preference_level5",
      "preference_level5_nosubtlety"
    ],
    "controlled": [
      "preference_controlled_5_0_0",
      "preference_controlled_10_0_0",
      "preference_controlled_15_0_0",
      "preference_controlled_20_0_0",
      "preference_controlled_20_0.1_0",
      "preference_controlled_20_0.2_0",
      "preference_controlled_20_0.3_0",
      "preference_controlled_20_0_0.1",
      "preference_controlled_20_0_0.2",
      "preference_controlled_20_0_0.3",
      "preference_controlled_20_0.1_0.1",
      "preference_controlled_20_0.2_0.2",
      "preference_controlled_20_0.3_0.3"
    ]
  },
  shoe: {
    "simple": [
      "shoe"
    ],
    "two_level": [
      "shoe_two_level_simple",
      "shoe_two_level_hard"
    ]
  }
};

// 2) CSV file paths (you can add more or rename them as needed).
//    Adjust these paths so they match your real GitHub Pages structure.
//    We use relative_url so it includes baseurl if necessary
const csvFiles = [
  "{{ '/assets/data/GPT_combined_results_synth.csv' | relative_url }}",
  "{{ '/assets/data/Llama_combined_results_synth.csv' | relative_url }}",
  "{{ '/assets/data/Qwen_combined_results_synth.csv' | relative_url }}",
  "{{ '/assets/data/DeepSeek_combined_results_synth.csv' | relative_url }}"
];

let allData = []; // will store rows from all CSVs
let table = null; // DataTables instance

//------------------------------------------------------------
// BUILD THE NESTED CHECKBOX UI
//------------------------------------------------------------
function buildNestedUI() {
  const container = document.getElementById('task-selector');
  container.innerHTML = '';

  // Iterate top-level categories
  for (const topCat in categories) {
    // Skip or handle 'All' if you want it special.
    if (topCat === 'All') continue;

    const subLevels = categories[topCat];

    // 1) Container for each top-level category
    const topDiv = document.createElement('div');
    topDiv.className = 'category-block';

    // 2) Top-level checkbox
    const topLabel = document.createElement('label');
    const topCheckbox = document.createElement('input');
    topCheckbox.type = 'checkbox';
    topCheckbox.value = topCat;
    topLabel.appendChild(topCheckbox);
    topLabel.appendChild(document.createTextNode(' ' + topCat));
    topDiv.appendChild(topLabel);

    // 3) Sub-level container
    const subContainer = document.createElement('div');
    subContainer.style.marginLeft = '1em';

    // Each sub-level (e.g., 'level 1', 'level 2')
    if (subLevels && typeof subLevels === 'object') {
      for (const levelName in subLevels) {
        const tasks = subLevels[levelName];

        const levelDiv = document.createElement('div');
        levelDiv.className = 'sub-block';

        // sub-level checkbox
        const levelLabel = document.createElement('label');
        const levelCheckbox = document.createElement('input');
        levelCheckbox.type = 'checkbox';
        levelCheckbox.value = levelName;

        levelLabel.appendChild(levelCheckbox);
        levelLabel.appendChild(document.createTextNode(' ' + levelName));
        levelDiv.appendChild(levelLabel);

        // tasks container
        const tasksDiv = document.createElement('div');
        tasksDiv.style.marginLeft = '1em';

        // build each task checkbox
        if (Array.isArray(tasks)) {
          tasks.forEach(taskName => {
            const taskLabel = document.createElement('label');
            taskLabel.style.display = 'block';
            const tcb = document.createElement('input');
            tcb.type = 'checkbox';
            tcb.value = taskName;
            taskLabel.appendChild(tcb);
            taskLabel.appendChild(document.createTextNode(' ' + taskName));
            tasksDiv.appendChild(taskLabel);

            // If user toggles an individual task
            tcb.addEventListener('change', () => {
              syncCheckbox(levelCheckbox, tasksDiv);
              syncCheckbox(topCheckbox, subContainer);
              updateLeaderboard();
            });
          });
        }

        levelDiv.appendChild(tasksDiv);
        subContainer.appendChild(levelDiv);

        // If user toggles the sub-level
        levelCheckbox.addEventListener('change', e => {
          const isChecked = e.target.checked;
          tasksDiv.querySelectorAll('input[type=checkbox]').forEach(child => {
            child.checked = isChecked;
          });
          syncCheckbox(topCheckbox, subContainer);
          updateLeaderboard();
        });
      }
    }

    topDiv.appendChild(subContainer);
    container.appendChild(topDiv);

    // If user toggles the top-level category
    topCheckbox.addEventListener('change', e => {
      const isChecked = e.target.checked;
      subContainer.querySelectorAll('input[type=checkbox]').forEach(child => {
        child.checked = isChecked;
      });
      updateLeaderboard();
    });
  }
}

// HELPER: Mark parent as checked/unchecked/indeterminate
function syncCheckbox(parentCheckbox, container) {
  const boxes = container.querySelectorAll('input[type=checkbox]');
  const allChecked = Array.from(boxes).every(b => b.checked);
  const noneChecked = Array.from(boxes).every(b => !b.checked);
  if (allChecked) {
    parentCheckbox.checked = true;
    parentCheckbox.indeterminate = false;
  } else if (noneChecked) {
    parentCheckbox.checked = false;
    parentCheckbox.indeterminate = false;
  } else {
    parentCheckbox.checked = false;
    parentCheckbox.indeterminate = true;
  }
}

// Gather all tasks that are checked
function getSelectedTasks() {
  const container = document.getElementById('task-selector');
  // sub-level -> tasks
  const leafBoxes = container.querySelectorAll('.sub-block div label input[type=checkbox]');
  const tasks = [];
  leafBoxes.forEach(b => {
    if (b.checked) {
      tasks.push(b.value);
    }
  });
  return tasks;
}

//------------------------------------------------------------
// 3) LOAD CSV FILES + DATATABLE
//------------------------------------------------------------

// Parse a single CSV with PapaParse
function loadCSV(file, callback) {
  Papa.parse(file, {
    download: true,
    header: true,
    skipEmptyLines: true,
    complete: function(results) {
      // Insert 'Model' from the file path, e.g. 'GPT', 'Llama', etc.
      results.data.forEach(row => {
        row.Model = file.split('_')[0].replace('{{ site.baseurl }}/assets/data/', '');
      });
      callback(results.data);
    }
  });
}

// Filter data by selected tasks
function filterByTasks(data, selectedTasks) {
  if (!selectedTasks || selectedTasks.length === 0) {
    // Return an empty array, or return data to show all tasks if none are selected.
    return [];
  }
  const allowed = new Set(selectedTasks);
  return data.filter(row => allowed.has(row.Task));
}

// Aggregate by (Model, Method)
function aggregateData(rows) {
  const map = new Map();
  rows.forEach(r => {
    const model = r.Model || 'Unknown';
    const method = r.Method || 'Unknown';
    const key = model + '||' + method;
    if (!map.has(key)) {
      map.set(key, {
        Model: model,
        Method: method,
        Accuracy: [],
        F1: [],
        Details: []
      });
    }
    const entry = map.get(key);
    entry.Accuracy.push(parseFloat(r.Accuracy));
    entry.F1.push(parseFloat(r.F1));
    entry.Details.push({ Task: r.Task, Accuracy: r.Accuracy, F1: r.F1 });
  });

  return Array.from(map.values()).map(e => {
    return {
      Model: e.Model,
      Method: e.Method,
      AvgAccuracy: (e.Accuracy.reduce((a, b) => a + b, 0) / e.Accuracy.length).toFixed(2),
      AvgF1: (e.F1.reduce((a, b) => a + b, 0) / e.F1.length).toFixed(2),
      Details: e.Details
    };
  });
}

// Render or re-render the DataTable
function renderTable(data) {
  // If we already have a table, destroy it
  if (table) {
    table.destroy();
    $('#leaderboard').empty();
  }

  // Build table data array
  const tableData = data.map(row => [
    row.Model,
    row.Method,
    row.AvgAccuracy,
    row.AvgF1,
    '<button class="details-btn">View</button>',
    JSON.stringify(row.Details)
  ]);

  table = $('#leaderboard').DataTable({
    data: tableData,
    columns: [
      { title: 'Model' },
      { title: 'Method' },
      { title: 'Avg Accuracy' },
      { title: 'Avg F1' },
      { title: 'Details' },
      { title: 'HiddenDetails', visible: false }
    ],
    // Default sort by F1 desc => column index 3
    order: [[3, 'desc']]
  });

  // On click 'View', expand row details
  $('#leaderboard tbody').on('click', 'button.details-btn', function() {
    const row = table.row($(this).parents('tr'));
    const details = JSON.parse(row.data()[5]);
    let html = '<div class="details"><strong>Per-Task Results:</strong><ul>';
    details.forEach(d => {
      html += `<li><strong>${d.Task}</strong>: Accuracy=${d.Accuracy}, F1=${d.F1}</li>`;
    });
    html += '</ul></div>';
    $(this).parent().append(html);
    $(this).remove();
  });
}

// Called whenever checkboxes change or after data loads
function updateLeaderboard() {
  const selectedTasks = getSelectedTasks();
  const filtered = filterByTasks(allData, selectedTasks);
  const aggregated = aggregateData(filtered);
  renderTable(aggregated);
}

// Initialize everything
function initLeaderboard() {
  // 1) Build the nested checkbox UI
  buildNestedUI();

  // 2) Load all CSVs
  let loadedCount = 0;
  csvFiles.forEach(file => {
    loadCSV(file, rows => {
      allData.push(...rows);
      loadedCount++;
      if (loadedCount === csvFiles.length) {
        // Everything loaded
        updateLeaderboard();
      }
    });
  });
}

// Start
initLeaderboard();
</script>
